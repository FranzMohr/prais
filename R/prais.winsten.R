#' Prais-Winsten Estimator for AR(1) Serial Correlation
#'
#' The Prais-Winsten estimator takes into account serial correlation of type AR(1) in a linear model.
#' The procedure recursively estimates the beta coefficients and the error autocorrelation
#' of the specified model until sufficient convergence of rho, i.e. the AR(1) coefficient, is attained. All estimates are obtained by OLS.
#'
#' @param formula an object of class "formula" (or one that can be coerced to that class): a symbolic description of the model to be fitted.
#' @param max_iter integer specifying the maximum number of iterations.
#' @param tol double the maximum (positive) value of the absolute difference between the estimator of rho in the current and the previous iteration that has to be attained to reach convergence and to stop the estimation. If not specified the value 1e-06 is used.
#' @param twostep logical specifying if estimation should stop after the first iteration.
#' @param ... further arguments passed on to \code{lm}.
#'
#' @references
#' Prais, S. J. and Winsten, C. B. (1954): Trend Estimators and Serial Correlation. Cowles Commission Discussion Paper, 383 (Chicago).
#'
#' Wooldridge, J. M. (2013): Introductory Econometrics. A Modern Approach. 5th ed. Mason, OH: South-Western Cengage Learning Cengage.
#'
#'@export
prais.winsten <- function(formula, max_iter = 50, tol = 1e-6, twostep = FALSE, ...){
  cl <- match.call()
  lm_temp <- stats::lm(formula = formula, ...)
  mod <- lm_temp$model

  intercept <- "(Intercept)" %in% names(lm_temp$coefficients)
  y_name <- names(mod)[1]
  x_name <- names(mod)[-1]
  x_formula <- paste(x_name, collapse = " + ")

  n <- nrow(mod)
  pos_t <- 2:n
  pos_t_lag <- 1:(n - 1)

  res <- lm_temp$res
  res_lag <- c(NA, res[-n])

  if (intercept) {
    mod <- data.frame(mod[, y_name], 1, mod[, x_name])
    names(mod) <- c(y_name, "const", x_name)
    sample_temp <- mod
    sample_formula <- stats::as.formula(paste(paste(paste(y_name, "~" ), "-1 + const +"), x_formula))
  } else {
    sample_temp <- mod
    sample_formula <- stats::as.formula(paste(paste(paste(y_name, "~" ), "-1 +"), x_formula))
  }

  rho_last <- 1000
  rho <- 0
  rho_stats <- data.frame("Iteration" = 0,"rho" = 0)
  if (twostep) {max_iter <- 1}
  i <- 1
  while(i <= max_iter & abs(rho - rho_last) > tol) {
    rho_lm <- stats::lm(res ~ res_lag - 1)
    rho_last <- rho
    rho <- rho_lm$coeff[1]
    rho_stats <- rbind(rho_stats, data.frame("Iteration" = i, "rho" = rho))

    sample_temp[, y_name] <- c((1 - rho^2)^(1 / 2) * mod[1, y_name], mod[pos_t, y_name] - rho * mod[pos_t_lag, y_name])
    if (intercept) {
      sample_temp[, "const"] <- c((1 - rho^2)^(1 / 2), rep(1 - rho, n - 1))
    }
    sample_temp[1, x_name] <- (1 - rho^2)^(1 / 2) * mod[1, x_name]
    sample_temp[-1, x_name] <- mod[pos_t, x_name] - rho * mod[pos_t_lag, x_name]

    lm_temp <- stats::lm(sample_formula, data = sample_temp)

    fit <- as.matrix(mod[, -1]) %*% lm_temp$coefficients
    res <- mod[, y_name] - fit
    res_lag <- c(NA, res[-n])
    cat("Iteration ", i, ": rho = ", round(rho, 4), "\n", sep = "")
    i <- i + 1
    if (i - 1 == max_iter & !twostep) {message("Estimation was stopped, because the maximum number of iterations was reached.")}
  }

  coeffs <- lm_temp$coefficients
  if (intercept) {
    names(coeffs)[which(names(coeffs) == "const")] <- "(Intercept)"
    mod <- mod[, -which(names(mod) == "const")]
  }
  row.names(rho_stats) <- NULL

  if (intercept) {
    x_name <- c("(Intercept)", x_name)
  }

  result <- list("coefficients" = coeffs,
                 "rho" = rho_stats,
                 "residuals" = res,
                 "fitted.values" = fit,
                 "call" = cl,
                 "model" = mod)
  class(result) <- append(class(result), "prais")
  return(result)
}
